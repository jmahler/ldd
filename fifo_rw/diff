--- ../data_rw/data.c	2013-08-14 11:09:14.759159167 -0700
+++ fifo.c	2013-08-16 00:04:03.966428656 -0700
@@ -5,154 +5,183 @@
 #include <linux/slab.h>
 #include <linux/uaccess.h>
 
-#define DEVICE_NAME "data"
-#define MAX_DATA 128
+#define DEVICE_NAME "fifo"
+#define MAX_DATA 3
 
-static dev_t data_major;
-struct class *data_class;
-struct device *data_device;
+static dev_t fifo_major;
+struct class *fifo_class;
+struct device *fifo_device;
 
-struct data_dev {
+struct fifo_dev {
 	struct cdev cdev;
-	char data[MAX_DATA];
-	loff_t cur_ofs;  // current offset
-} *data_devp;
+	char fifo[MAX_DATA];
+	char *read_ptr;
+	char *write_ptr;
+	char *fifo_start;
+	char *fifo_end;
+	int empty;
+} *fifo_devp;
 
-static int data_open(struct inode* inode, struct file* filp)
+int fifo_open(struct inode* inode, struct file* filp)
 {
-	struct data_dev *data_devp;
+	struct fifo_dev *fifo_devp;
 
-	data_devp = container_of(inode->i_cdev, struct data_dev, cdev);
-	data_devp->cur_ofs = 0;
+	fifo_devp = container_of(inode->i_cdev, struct fifo_dev, cdev);
 
-	filp->private_data = data_devp;
+	filp->private_data = fifo_devp;
 
 	return 0;
 }
 
-static ssize_t data_read(struct file *filp, char __user *buf, size_t count,
+static ssize_t fifo_read(struct file *filp, char __user *buf, size_t count,
 					loff_t *f_pos)
 {
-	struct data_dev *data_devp = filp->private_data;
-	loff_t cur_ofs;
-	char *datp;
+	struct fifo_dev *dev = filp->private_data;
 	size_t left;
 
-	cur_ofs = data_devp->cur_ofs;
-	datp = data_devp->data;
-	left = MAX_DATA - cur_ofs;
+	left = count;
 
-	count = (count > left) ? left : count;
+	while (left) {
 
-	if (copy_to_user(buf, (void *) (datp + cur_ofs), count) != 0) {
-		return -EIO;
-	}
+		if (dev->empty) {
+			break;
+		}
+
+		if (copy_to_user(buf, (void *) dev->read_ptr, 1) != 0) {
+			return -EIO;
+		}
+		left--;
 
-	data_devp->cur_ofs = cur_ofs + count;
+		if (dev->read_ptr == dev->fifo_end) {
+			dev->read_ptr = dev->fifo_start;
+		} else {
+			(dev->read_ptr)++;
+		}
 
-	return count;
+		if (dev->read_ptr == dev->write_ptr) {
+			dev->empty = 1;
+		}
+	}
+
+	return (count - left);
 }
 
-static ssize_t data_write(struct file *filp, const char __user *buf, size_t count,
+static ssize_t fifo_write(struct file *filp, const char __user *buf, size_t count,
 					loff_t *f_pos)
 {
-	struct data_dev *data_devp = filp->private_data;
-	loff_t cur_ofs;
-	char *datp;
+	struct fifo_dev *dev = filp->private_data;
 	size_t left;
 
-	cur_ofs = data_devp->cur_ofs;
-	datp = data_devp->data;
-	left = MAX_DATA - cur_ofs;
+	left = count;
 
-	count = (count > left) ? left : count;
+	while (left) {
 
-	if (copy_from_user((void *) (datp + cur_ofs), buf, count) != 0) {
-		return -EIO;
-	}
+		if (!(dev->empty) && (dev->read_ptr == dev->write_ptr)) {
+			break;
+		}
 
-	data_devp->cur_ofs = cur_ofs + count;
+		if (copy_from_user((void *) dev->write_ptr, buf, 1) != 0) {
+			return -EIO;
+		}
+		left--;
 
-	return count;
+		if (dev->empty)
+			dev->empty = 0;
+
+		if (dev->write_ptr == dev->fifo_end) {
+			dev->write_ptr = dev->fifo_start;
+		} else {
+			(dev->write_ptr)++;
+		}
+	}
+
+	return (count - left);
 }
 
-static int data_release(struct inode *inode, struct file *filp)
+static int fifo_release(struct inode *inode, struct file *filp)
 {
 	return 0;
 }
 
-struct file_operations data_fops = {
+struct file_operations fifo_fops = {
 	.owner = THIS_MODULE,
-	.open = data_open,
-	.read = data_read,
-	.write = data_write,
-	.release = data_release,
+	.open = fifo_open,
+	.read = fifo_read,
+	.write = fifo_write,
+	.release = fifo_release,
 };
 
-static int __init data_init(void)
+static int __init fifo_init(void)
 {
 	int err = 0;
 
-	err = alloc_chrdev_region(&data_major, 0, 1, DEVICE_NAME);
+	err = alloc_chrdev_region(&fifo_major, 0, 1, DEVICE_NAME);
 	if (err < 0) {
 		printk(KERN_WARNING "Unable to register device\n");
 		goto err_chrdev_region;
 	}
 
-	data_class = class_create(THIS_MODULE, DEVICE_NAME);
+	fifo_class = class_create(THIS_MODULE, DEVICE_NAME);
 
-	data_devp = kmalloc(sizeof(struct data_dev), GFP_KERNEL);
-	if (!data_devp) {
-		printk(KERN_WARNING "Unable to kmalloc data_devp\n");
+	fifo_devp = kmalloc(sizeof(struct fifo_dev), GFP_KERNEL);
+	if (!fifo_devp) {
+		printk(KERN_WARNING "Unable to kmalloc fifo_devp\n");
 		err = -ENOMEM;
 		goto err_malloc_devp;
 	}
 
-	cdev_init(&data_devp->cdev, &data_fops);
-	data_devp->cdev.owner = THIS_MODULE;
-	err = cdev_add(&data_devp->cdev, data_major, 1);
+	cdev_init(&fifo_devp->cdev, &fifo_fops);
+	fifo_devp->cdev.owner = THIS_MODULE;
+
+	fifo_devp->fifo_start = &fifo_devp->fifo[0];
+	fifo_devp->fifo_end = &fifo_devp->fifo[MAX_DATA-1];
+	fifo_devp->read_ptr = &fifo_devp->fifo[0];
+	fifo_devp->write_ptr = &fifo_devp->fifo[0];
+	fifo_devp->empty = 1;
+
+	err = cdev_add(&fifo_devp->cdev, fifo_major, 1);
 	if (err) {
 		printk(KERN_WARNING "cdev_add failed\n");
 		goto err_cdev_add;
 	}
 
-	data_device = device_create(data_class, NULL,
-							MKDEV(MAJOR(data_major), 0), NULL, "data%d",0);
-	if (IS_ERR(data_device)) {
+	fifo_device = device_create(fifo_class, NULL,
+							MKDEV(MAJOR(fifo_major), 0), NULL, "fifo%d",0);
+	if (IS_ERR(fifo_device)) {
 		printk(KERN_WARNING "device_create failed\n");
-		err = PTR_ERR(data_device);
+		err = PTR_ERR(fifo_device);
 		goto err_device_create;
 	}
 
 	return 0;  /* success */
 
 err_device_create:
-	cdev_del(&data_devp->cdev);
+	cdev_del(&fifo_devp->cdev);
 err_cdev_add:
-	kfree(data_devp);
+	kfree(fifo_devp);
 err_malloc_devp:
-	class_destroy(data_class);
-	unregister_chrdev_region(data_major, 1);
+	class_destroy(fifo_class);
+	unregister_chrdev_region(fifo_major, 1);
 err_chrdev_region:
 
 	return err;
 }
 
-static void __exit data_exit(void)
+static void __exit fifo_exit(void)
 {
-	device_destroy(data_class, data_major);
+	device_destroy(fifo_class, fifo_major);
 
-	cdev_del(&data_devp->cdev);
+	cdev_del(&fifo_devp->cdev);
 
-	kfree(data_devp);
+	kfree(fifo_devp);
 
-	class_destroy(data_class);
+	class_destroy(fifo_class);
 
-	unregister_chrdev_region(data_major, 1);
+	unregister_chrdev_region(fifo_major, 1);
 }
 
 MODULE_AUTHOR("Jeremiah Mahler <jmmahler@gmail.com>");
 MODULE_LICENSE("GPL");
 
-module_init(data_init);
-module_exit(data_exit);
+module_init(fifo_init);
+module_exit(fifo_exit);
